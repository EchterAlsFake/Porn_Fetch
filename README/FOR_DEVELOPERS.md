# General help + explanation for devs
If you want to work on this project and help contributing, or just want to change things for yourself,
because you maybe want to add certain features, change appearance or whatever, this documentation
will in detail explain how this project is structured and how to work with it.


### Dependencies
This project depends on Python. You ideally want to use Python 3.13. Apart from that, you need `git` to clone 
the project. 

If you want to work on the Android side of things, you need Kotlin and either Android Studio, or Jetbrains IntelliJ. 

For installing the dependencies you want to use `uv`. You can install it by running: 
<br>`curl -LsSf https://astral.sh/uv/install.sh | sh`

After that, just go into the project directory and run: `uv sync --extra dev` and it will install all the stuff you need.


## Project Structure
### Most important files
- Main GUI: `main`.py
- MAIN CLI: `Porn_Fetch_CLI.py`
- UI Update script: `src/frontend/update.sh` (Linux) | `src/frontend/update.ps1` (Windows)
- macOS Patch script: `src/scripts/patch_macos_bundle.py`

Porn Fetch files are split into 4 directories:

- `src/backend` Used for all backend logic e.g., fetching data or functions shared between CLI and GUI
- `src/frontend` Used for graphic assets, User interface code + UI files and translations
- `src/build` Contains the build scripts for the `pyside6-deploy` script
- `src/scripts` Contains the automatic build scripts as well as the macOS patch script

#### The macOS Patch Script
If you work on macOS with Porn Fetch and you want to produce a final .app / .dmg file, that you can actually
ship to users, e.g., if you want to make custom-builds for Porn Fetch, you can use this script to automatically
patch the .app bundle to contain a correct `Info.plist` file with the correct version and the automatic
integration into the Sparkle Framework (more info on that down below)

It will also automatically generate a .dmg container from the .app bundle, so that you can ship it on platforms.

### The UI Update Script
This script is essential for updating the user interface for the newest Qt version and also making sure
the UI looks the same on all platforms. The files generated by this script are not always cross compatible
and some platforms have their own logic. 

So, you should always run this script if
- You updated the Qt version
- You run the UI for the first time
- You changed something in the UI or the ressource file

### The resource file
This file basically bundles the graphics, translations and stylesheets and creates a Python file that I can import,
so that I can reference the assets in my code and still ship one file and not a whole directory. 

### The Sparkle Framework
The [Sparkle Framework](http://sparkle-project.org/) is used in Porn Fetch to allow automatic native updating on macOS.
It is directly integrated into the repository, because I am compiling Porn Fetch on a virtual machine and handling updating
there by manually downloading it each time and so on is just very annoying. 

The macOS Patch script handles the automatic integration into the `Info.plist` file. The rest is fully automatic in code.
Sparkle provides a native like feel to update the .app package and is independent of the programming language, as long as
you can call it, which is done in the: `src/backend/macos_setup.py` file. 

Sparkle is not included on all other platforms and the code logic will not be executed / used there. 

# Explanation of the main code
The: `LicenseWidget` class. 

This basically shows the user the dialog / widget for importing the license for Porn Fetch. This is still 
in test mode, and you don't need that while developing. If you run Porn Fetch from source code, all features
are unlocked by default, unless you explicitly change stuff in the code. 

The: `InstallThread` class. 

This handles installation of Porn Fetch on Linux and Windows and creates a native desktop integration as you would
expect from "regular" (non porn focused meme) apps. You probably also don't need that during development.

The: `UninstallThread` class. 

As it says, it reverts everything the InstallThread class did and will completely uninstall Porn Fetch from your system.

The: `AutoUpdatingThread` class. 

This handles automatic updating of Porn Fetch by asking my server at: `https://echteralsfake.me/update` if there's 
an update available and if yes, it will fetch the asset URLs and automatically handle updating Porn Fetch. 

The: `InternetCheck` class. 

This basically just does a quick check to all sites if Porn Fetch can reach them and if not, shows
a dialog to the user why it failed. 

The: `AddToTreeWidget` class. 

Now, this is the interesting part. The AddToTreeWidget class is used to load the actual videos. Basically, when
the user enters a URL, the `Video` objects (see below) are retrieved from the underlying APIs (see down below). After
the information of each video is extracted, it will form a QTreeWidgetItem and save the data in there and set the QCheckBox,
so that users can select the video they want to download. 

The class also automatically handles errors and refetching in case a video fails. Errors can be automatically reported. 
The function runs in a QThread via QRunnable, so that it doesn't block the main thread. There's also progress reporting on
how many videos have already been fetched.

The data is generally transmitted via QSignal calls. This applies to all classes that use QRunnable. 

The: `DownloadThread` class.

This class, as you can guess, handles the actual downloading of video objects. However, it only calls the actual download.
The download itself is handled by the video object itself, or if you go deeper by the `eaf_base_api`.
It will use ThreadPool to download the different segments (if the video uses HLS) and then merge them together.

The: `QTreeWidgetDownloadThread` class.

This will be executed when the user clicks on the actual download button down below. It will check if a video object
was checked in the QTreeWidget and if yes, it will invoke the `DownloadThread` class and start the video download.
Before doing that, it will fetch a list of all segments, so that we can use total progress reporting for HLS videos.

The: `PornFetch` class.

This is the main class that sets up the UI, has all the functions and the main logic. All functions there should be
self-explaining. (Hopefully).


### Backend Logic
Porn Fetch's main logic for handling the videos is executed by the APIs. Those are web-scraping wrappers of all
the supported sites using httpx to fetch content and beautifulsoup4 + lxml to parse data.

Each API exposes a `Client` class. This class initializes the API and its configuration and allows for calls like:

`.get_video(<url>)` -> Fetch a Video using a URL and return a `Video` objects
`.search(<query>)` -> Search for videos using a search Query, return a Generator of `Video` objects

It all comes down to the Video object in the end. 

The `Video` object is just a class in the APIs that takes the URL, fetches the HTML content and then extracts data
from it, like the title, author, thumbnail AND the m3u8 URL which is the source of the segments for the video.

Here's a code snippet from the API for `xnxx.com`, so that you can see how that actually looks in code:

```python
class Video:
    def __init__(self, url: str, core: Optional[BaseCore] = None) -> None:
        self.url = url
        self.core = core
        self.core.enable_logging(level=logging.DEBUG)
        self.logger = setup_logger(name="MISSAV API - [Video]", log_file=None, level=logging.CRITICAL)
        self.content = self.core.fetch(url)
        self.soup = BeautifulSoup(self.content, "lxml")
        _meta_div = self.soup.find("div", class_="space-y-2")
        self.meta_divs = _meta_div.find_all("div", class_="text-secondary")

    def enable_logging(self, level, log_file: str = None):
        self.logger = setup_logger(name="MISSAV API - [Video]", log_file=log_file, level=level)

    @cached_property
    def title(self) -> str:
        """Returns the title of the video. Language depends on the URL language"""
        return self.soup.find("h1", class_="text-base lg:text-lg text-nord6").text.strip()

    @cached_property
    def publish_date(self) -> str:
        """Returns the publish date of the video"""
        return self.meta_divs[0].find("time", class_="font-medium").text.strip()
```

As you can see, it's all very simple and everyone could do that. It's just that nobody has the time for it, and nobody
wants to have a project with "Porn" in their resume lmao.


### Networking
Because the networking of Porn Fetch, especially with all the supported configuration options and
proxy support got so complex, I created my own library just for that which uses httpx though.

You can find that here: https://github.com/EchterAlsFake/eaf_base_api

However, I won't document how this works, because it's just too much. Like this project alone is like 1500 lines of code.

### Metadata
Because the streams of the segments are in `MPEG-TS` format, I can't just write metadata into that. I need to remux that
into a valid mp4 container. This will be done by ffmpeg. However, because I am too lazy to ship ffmpeg with Porn Fetch,
I am using `pyav` instead, which will bundle ffmpeg on its own. 

This logic is also handled in `eaf_base_api`.


# .

I actually started this project as a joke, but you know it got so complex over time. Without the UI code, we 
are probably at 10.000-15.000 lines here and sure you could optimize that a lot probably, but still.

It's the reason why I don't give up this project, even if a lot of people laugh at me for it, because it makes
me happy and I learned stuff that you don't learn in the YouTube tutorials :)














